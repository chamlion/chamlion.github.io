<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="The world is so beautiful, it is worth people to strive for it">
<meta property="og:type" content="website">
<meta property="og:title" content="chamlion&#39;blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="chamlion&#39;blog">
<meta property="og:description" content="The world is so beautiful, it is worth people to strive for it">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chamlion&#39;blog">
<meta name="twitter:description" content="The world is so beautiful, it is worth people to strive for it">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>chamlion'blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">chamlion'blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/04/redis源码阅读-跳跃表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chamlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chamlion'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/04/redis源码阅读-跳跃表/" itemprop="url">redis源码阅读--跳跃表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-04T23:00:06+08:00">
                2018-07-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="跳跃表概念"><a href="#跳跃表概念" class="headerlink" title="跳跃表概念"></a>跳跃表概念</h1><p>这篇文章介绍的不错<br><a href="https://my.oschina.net/ljc94/blog/807388" target="_blank" rel="noopener">https://my.oschina.net/ljc94/blog/807388</a><br>原理类似于二分查找。在链表有序，节点数为n的情况下，先比较m节点(m为随机产生的节点)，大于的话查找范围变为(0-m)。否则(m-0)。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    // 成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line">    // 分值</span><br><span class="line">    double score;</span><br><span class="line">    // 后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    // 层</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        // 前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        // 跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以一个跳跃表节点，<br>包含节点值(成员对象)<br>后退指针(这样就是一个双向链了)<br>分值(是用来排序的，类似于key，不过可以是重复的)<br>层，其实就是对应的n层查找链，里面包含了每层下一个查找的指针，以及和上一个节点的距离。<br>跳跃表管理节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    // 表头节点和表尾节点</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">    // 表中节点的数量</span><br><span class="line">    unsigned long length;</span><br><span class="line">    // 表中层数最大的节点的层数</span><br><span class="line">    int level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p>
<p>这个没啥好说的</p>
<h1 id="跳跃表的创建"><a href="#跳跃表的创建" class="headerlink" title="跳跃表的创建"></a>跳跃表的创建</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">zskiplist *zslCreate(void) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    // 分配空间</span><br><span class="line">    zsl = zmalloc(sizeof(*zsl));</span><br><span class="line">    // 设置高度和起始层数</span><br><span class="line">    zsl-&gt;level = 1;</span><br><span class="line">    zsl-&gt;length = 0;</span><br><span class="line">    // 初始化表头节点</span><br><span class="line">    // T = O(1)</span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);</span><br><span class="line">    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = NULL;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = NULL;</span><br><span class="line">    // 设置表尾</span><br><span class="line">    zsl-&gt;tail = NULL;</span><br><span class="line">    return zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没啥好说的，略过</p>
<h1 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h1><p>查找第一个分值满足要求的节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    // 最小值和最大值</span><br><span class="line">    double min, max;</span><br><span class="line"></span><br><span class="line">    // 指示最小值和最大值是否*不*包含在范围之内</span><br><span class="line">    // 值为 1 表示不包含，值为 0 表示包含</span><br><span class="line">    int minex, maxex; /* are min or max exclusive? */</span><br><span class="line">&#125; zrangespec;</span><br><span class="line">zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    int i;</span><br><span class="line">    /* If everything is out of range, return early. */</span><br><span class="line">    if (!zslIsInRange(zsl,range)) return NULL;</span><br><span class="line">    // 遍历跳跃表，查找符合范围 min 项的节点</span><br><span class="line">    // T_wrost = O(N), T_avg = O(log N)</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</span><br><span class="line">        /* Go forward while *OUT* of range. */</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    /* This is an inner range, so the next node cannot be NULL. */</span><br><span class="line">    x = x-&gt;level[0].forward;</span><br><span class="line">    redisAssert(x != NULL);</span><br><span class="line">    /* Check if score &lt;= max. */</span><br><span class="line">    // 检查节点是否符合范围的 max 项</span><br><span class="line">    // T = O(1)</span><br><span class="line">    if (!zslValueLteMax(x-&gt;score,range)) return NULL;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">看这意思就是从最顶层开始找，一层一层找。</span><br><span class="line"></span><br><span class="line"># 插入一个节点</span><br><span class="line"></span><br><span class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    unsigned int rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    int i, level;</span><br><span class="line"></span><br><span class="line">    redisAssert(!isnan(score));</span><br><span class="line"></span><br><span class="line">    // 在各个层查找节点的插入位置</span><br><span class="line">    // T_wrost = O(N^2), T_avg = O(N log N)</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</span><br><span class="line"></span><br><span class="line">        /* store rank that is crossed to reach the insert position */</span><br><span class="line">        // 如果 i 不是 zsl-&gt;level-1 层</span><br><span class="line">        // 那么 i 层的起始 rank 值为 i+1 层的 rank 值</span><br><span class="line">        // 各个层的 rank 值一层层累积</span><br><span class="line">        // 最终 rank[0] 的值加一就是新节点的前置节点的排位</span><br><span class="line">        // rank[0] 会在后面成为计算 span 值和 rank 值的基础</span><br><span class="line">        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];</span><br><span class="line"></span><br><span class="line">        // 沿着前进指针遍历跳跃表</span><br><span class="line">        // T_wrost = O(N^2), T_avg = O(N log N)</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                // 比对分值</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                // 比对成员， T = O(N)</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; 0))) &#123;</span><br><span class="line"></span><br><span class="line">            // 记录沿途跨越了多少个节点</span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line"></span><br><span class="line">            // 移动至下一指针</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        // 记录将要和新节点相连接的节点</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* we assume the key is not already inside, since we allow duplicated</span><br><span class="line">     * scores, and the re-insertion of score and redis object should never</span><br><span class="line">     * happen since the caller of zslInsert() should test in the hash table</span><br><span class="line">     * if the element is already inside or not. </span><br><span class="line">     *</span><br><span class="line">     * zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</span><br><span class="line">     * 所以这里不需要进一步进行检查，可以直接创建新元素。</span><br><span class="line">     */</span><br><span class="line">    // 获取一个随机值作为新节点的层数</span><br><span class="line">    // T = O(N)</span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    // 如果新节点的层数比表中其他节点的层数都要大</span><br><span class="line">    // 那么初始化表头节点中未使用的层，并将它们记录到 update 数组中</span><br><span class="line">    // 将来也指向新节点</span><br><span class="line">    if (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        // 初始化未使用层</span><br><span class="line">        // T = O(1)</span><br><span class="line">        for (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = 0;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新表中节点最大层数</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    // 创建新节点</span><br><span class="line">    x = zslCreateNode(level,score,obj);</span><br><span class="line">    // 将前面记录的指针指向新节点，并做相应的设置</span><br><span class="line">    // T = O(1)</span><br><span class="line">    for (i = 0; i &lt; level; i++) &#123;</span><br><span class="line">        // 设置新节点的 forward 指针</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        // 将沿途记录的各个节点的 forward 指针指向新节点</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line">        /* update span covered by update[i] as x is inserted here */</span><br><span class="line">        // 计算新节点跨越的节点数量</span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);</span><br><span class="line">        // 更新新节点插入之后，沿途节点的 span 值</span><br><span class="line">        // 其中的 +1 计算的是新节点</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* increment span for untouched levels */</span><br><span class="line">    // 未接触的节点的 span 值也需要增一，这些节点直接从表头指向新节点</span><br><span class="line">    // T = O(1)</span><br><span class="line">    for (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置新节点的后退指针</span><br><span class="line">    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];</span><br><span class="line">    if (x-&gt;level[0].forward)</span><br><span class="line">        x-&gt;level[0].forward-&gt;backward = x;</span><br><span class="line">    else</span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    // 跳跃表的节点计数增一</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line"></span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑大概是，遍历整个跳跃表，得到每一层他的forward指针要指向节点的指针。<br>然后再插入，更新每一层该节点的相关指针的指向。</p>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>类似于插入</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论是插入还是查询性能，都还不错，平均logn。<br>使用场景：适用于范围查找，单个key的查找还是上hash表，<br>且实现起来比平衡树之类的简单一些，空间复杂度也差不多。实现难度也小一些。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/redis源码阅读-字典哈希表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chamlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chamlion'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/redis源码阅读-字典哈希表/" itemprop="url">以redis源码阅读--字典哈希表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-02T23:33:52+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计时考虑的点"><a href="#设计时考虑的点" class="headerlink" title="设计时考虑的点"></a>设计时考虑的点</h1><p>查找、插入、删除操作要注意效率。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>redis中字典时基于哈希表作为底层的实现。所以首先看hash表的实现<br>哈希表的实现，就是设置好哈希表的大小后，对键进行哈希运算后，对size求余。哈希冲突采取存入槽位相同的链解决。<br>提高查找效率采取，每次将键值对插入链表头实现。<br>缺点，查找效率不高<br>亮点：rehash操作，采取渐进式rehash，也就是每次增删查改操作，迁移一个旧的hash表中的键值对。<br>哈希表结构定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 哈希表</span><br><span class="line"> *</span><br><span class="line"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</span><br><span class="line"> */</span><br><span class="line">typedef struct dictht &#123;</span><br><span class="line">    </span><br><span class="line">    // 哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    // 哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line">    // 哈希表大小掩码，用于计算索引值</span><br><span class="line">    // 总是等于 size - 1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    // 该哈希表已有节点的数量</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    // 键</span><br><span class="line">    void *key;</span><br><span class="line">    // 值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;    </span><br><span class="line">		//这里面用联合体很有意思，如果想把v看作当整数取出，直接v.u64</span><br><span class="line">    &#125; v;</span><br><span class="line">    // 指向下个哈希表节点，形成链表</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>这里面采用dictEntry来存储每个键值对，table是一个二维数组。<br>举个例子，table[0][1]保存的是，hash值为0的链表中第二个节点。</p>
<h1 id="字典的定义"><a href="#字典的定义" class="headerlink" title="字典的定义"></a>字典的定义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    // 类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line">    // 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line">    // 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    // rehash 索引</span><br><span class="line">    // 当 rehash 不在进行时，值为 -1</span><br><span class="line">    int rehashidx; /* rehashing not in progress if rehashidx == -1 */</span><br><span class="line">    // 目前正在运行的安全迭代器的数量</span><br><span class="line">    int iterators; /* number of iterators currently running */</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>可以看到有俩哈希表成员，一个是用来存储键值对，一个是对哈希表进行rehash操作时使用，<br>还有一个成员dictType *type;主要用来存储关于哈希表键值对相关的操作函数。<br>具体包括<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictType &#123;</span><br><span class="line">    // 计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line">    // 复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line">    // 复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata, const void *obj);</span><br><span class="line">    // 对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br><span class="line">    // 销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *privdata, void *key);</span><br><span class="line">    // 销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *privdata, void *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure></p>
<h1 id="字典的创建。"><a href="#字典的创建。" class="headerlink" title="字典的创建。"></a>字典的创建。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dict *dictCreate(dictType *type,</span><br><span class="line">        void *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    dict *d = zmalloc(sizeof(*d));</span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line">int _dictInit(dict *d, dictType *type,</span><br><span class="line">        void *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化两个哈希表的各项属性值</span><br><span class="line">    // 但暂时还不分配内存给哈希表数组</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[0]);</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[1]);</span><br><span class="line">    // 设置类型特定函数</span><br><span class="line">    d-&gt;type = type;</span><br><span class="line">    // 设置私有数据</span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line">    // 设置哈希表 rehash 状态</span><br><span class="line">    d-&gt;rehashidx = -1;</span><br><span class="line">    // 设置字典的安全迭代器数量</span><br><span class="line">    d-&gt;iterators = 0;</span><br><span class="line">    return DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个新建没啥好说的</p>
<h1 id="插入键值对"><a href="#插入键值对" class="headerlink" title="插入键值对"></a>插入键值对</h1><p>首先根据键值对的键，计算哈希值，然后在通过求余，得到索引值。将其插入对应索引的链表中，<br>为了提高插入效率，总是插入在行首。<br>具体代码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">dictEntry *dictAddRaw(dict *d, void *key)</span><br><span class="line">&#123;</span><br><span class="line">    int index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line">    // 如果条件允许的话，进行单步 rehash</span><br><span class="line">    // T = O(1)</span><br><span class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    /* Get the index of the new element, or -1 if</span><br><span class="line">     * the element already exists. */</span><br><span class="line">    // 计算键在哈希表中的索引值</span><br><span class="line">    // 如果值为 -1 ，那么表示键已经存在</span><br><span class="line">    // T = O(N)</span><br><span class="line">    if ((index = _dictKeyIndex(d, key)) == -1)</span><br><span class="line">        return NULL;</span><br><span class="line">    // T = O(1)</span><br><span class="line">    /* Allocate the memory and store the new entry */</span><br><span class="line">    // 如果字典正在 rehash ，那么将新键添加到 1 号哈希表</span><br><span class="line">    // 否则，将新键添加到 0 号哈希表</span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];</span><br><span class="line">    // 为新节点分配空间</span><br><span class="line">    entry = zmalloc(sizeof(*entry));</span><br><span class="line">    // 将新节点插入到链表表头</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    // 更新哈希表已使用节点数量</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line">    /* Set the hash entry fields. */</span><br><span class="line">    // 设置新节点的键</span><br><span class="line">    // T = O(1)</span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    return entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中将键值对插入队首的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 将新节点插入到链表表头</span><br><span class="line">   entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">   ht-&gt;table[index] = entry;</span><br></pre></td></tr></table></figure></p>
<p>这个写法可以借鉴。</p>
<h1 id="节点查找操作"><a href="#节点查找操作" class="headerlink" title="节点查找操作"></a>节点查找操作</h1><p>就是查找hash值对应的链，这部操作T(1)的时间复杂度，然后遍历这条链。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">dictEntry *dictFind(dict *d, const void *key)</span><br><span class="line">&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    unsigned int h, idx, table;</span><br><span class="line">    // 字典（的哈希表）为空</span><br><span class="line">    if (d-&gt;ht[0].size == 0) return NULL; /* We don&apos;t have a table at all */</span><br><span class="line">    // 如果条件允许的话，进行单步 rehash</span><br><span class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    // 计算键的哈希值</span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    // 在字典的哈希表中查找这个键</span><br><span class="line">    // T = O(1)</span><br><span class="line">    for (table = 0; table &lt;= 1; table++) &#123;</span><br><span class="line">        // 计算索引值</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        // 遍历给定索引上的链表的所有节点，查找 key</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        // T = O(1)</span><br><span class="line">        while(he) &#123;</span><br><span class="line"></span><br><span class="line">            if (dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                return he;</span><br><span class="line"></span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果程序遍历完 0 号哈希表，仍然没找到指定的键的节点</span><br><span class="line">        // 那么程序会检查字典是否在进行 rehash ，</span><br><span class="line">        // 然后才决定是直接返回 NULL ，还是继续查找 1 号哈希表</span><br><span class="line">        if (!dictIsRehashing(d)) return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    // 进行到这里时，说明两个哈希表都没找到</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>采用MurmurHash2算法，有点是即使数据很有规律，仍能有很好的随机分布性，且算法速度不错。</p>
<h1 id="rehash算法"><a href="#rehash算法" class="headerlink" title="rehash算法"></a>rehash算法</h1><p>Q：为啥需要<br>A：因为需要根据哈希表保存实际键值对的多少，对哈希表的大小做调整。也就是为了考虑空间效率，优化内存。<br>步骤<br>1、根据目前哈希表内元素多少，创建适当大小空间。具体的算法是<br>ht[1].size=ht[0].used*2的n次幂。<br>这里面有个比较亮的点，渐进式rehash，其实就是个啥，每次增删查改的时候，将ht[0]中的一个元素，迁移到ht[2]中。<br>也就是不集中进行rehash操作，将迁移分散。<br>Q：有个问题，如果每次操作都是动态改变大小，这样进行调整大小操作合不合理<br>A：所以这里涉及到一个负载因子<br>load_factor = used/size<br>当负载因子小于5时，进行扩容操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp;</span><br><span class="line">    (dict_can_resize ||</span><br><span class="line">     d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio))  //dict_force_resize_ratio=5</span><br><span class="line">&#123;</span><br><span class="line">    // 新哈希表的大小至少是目前已使用节点数的两倍</span><br><span class="line">    // T = O(N)</span><br><span class="line">    return dictExpand(d, d-&gt;ht[0].used*2);</span><br></pre></td></tr></table></figure></p>
<h1 id="可以改进的点"><a href="#可以改进的点" class="headerlink" title="可以改进的点"></a>可以改进的点</h1><p>为了提高插入的操作，每次插入都将点插入hash值相同链表的首节点，这样提高了插入效率<br>但是却使得查询操作，比较耗时，必须将hash值链表所有节点遍历一遍才可以。<br>所以有两种改进方案<br>1、保持原来设计，但是在使用的时候要控制相同hash值链的长度。也就是注意调整哈希表的大小。<br>2、改变插入逻辑，每次插入链表时按照一定顺序插入，比如从大到小，这样，可能损失一部分插入效率<br>但会提高查询效率。<br>具体使用还是看使用场景。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/01/redis源码阅读-双端链表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chamlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chamlion'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/redis源码阅读-双端链表/" itemprop="url">redis源码阅读--双端链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-01T22:48:04+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计时考虑的点"><a href="#设计时考虑的点" class="headerlink" title="设计时考虑的点"></a>设计时考虑的点</h1><p>1、实现基本功能，包括链表正向遍历，反向遍历，任意位置插入节点。删除指定节点，记录链表长度。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先看链表节点定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line"></span><br><span class="line">    // 前置节点</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    // 后置节点</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    // 节点的值</span><br><span class="line">    void *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure></p>
<p>这没啥好说的，中规中矩<br>有的链表实现是，仅仅将多个listnode串起来，组成链表。redis里面为了更好的管理，通过以下结构来保存链表信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">    // 表头节点</span><br><span class="line">    listNode *head;</span><br><span class="line">    // 表尾节点</span><br><span class="line">    listNode *tail;</span><br><span class="line">    // 节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    // 节点值释放函数</span><br><span class="line">    void (*free)(void *ptr);</span><br><span class="line">    // 节点值对比函数</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line">    // 链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，作者在设计的时候，提供了三个函数成员。也就是在创建的时候，可以指定节点的复制、释放、比较函数。也算一种多态的实现吧。</p>
<h1 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">list *listCreate(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct list *list;</span><br><span class="line">    // 分配内存</span><br><span class="line">    if ((list = zmalloc(sizeof(*list))) == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    // 初始化属性</span><br><span class="line">    list-&gt;head = list-&gt;tail = NULL;</span><br><span class="line">    list-&gt;len = 0;</span><br><span class="line">    list-&gt;dup = NULL;</span><br><span class="line">    list-&gt;free = NULL;</span><br><span class="line">    list-&gt;match = NULL;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平淡无奇。</p>
<h1 id="链表节点的插入"><a href="#链表节点的插入" class="headerlink" title="链表节点的插入"></a>链表节点的插入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">list *listAddNodeHead(list *list, void *value)</span><br><span class="line">&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line">    // 为节点分配内存</span><br><span class="line">    if ((node = zmalloc(sizeof(*node))) == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    // 保存值指针</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    // 添加节点到空链表</span><br><span class="line">    if (list-&gt;len == 0) &#123;</span><br><span class="line">        list-&gt;head = list-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = NULL;</span><br><span class="line">    // 添加节点到非空链表</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        node-&gt;prev = NULL;</span><br><span class="line">        node-&gt;next = list-&gt;head;</span><br><span class="line">        list-&gt;head-&gt;prev = node;</span><br><span class="line">        list-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    // 更新链表节点数</span><br><span class="line">    list-&gt;len++;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节点的插入，这里面是直接传入节点中的value值，而不是已经初始化好的节点。<br>感觉有个不好的点，如果是从A链表中弹出的节点，插入B链时，还要新建一个节点，而不是改一下指针就好了</p>
<h1 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void listDelNode(list *list, listNode *node)</span><br><span class="line">&#123;</span><br><span class="line">    // 调整前置节点的指针</span><br><span class="line">    if (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    else</span><br><span class="line">        list-&gt;head = node-&gt;next;</span><br><span class="line">    // 调整后置节点的指针</span><br><span class="line">    if (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    else</span><br><span class="line">        list-&gt;tail = node-&gt;prev;</span><br><span class="line">    // 释放值</span><br><span class="line">    if (list-&gt;free) list-&gt;free(node-&gt;value);</span><br><span class="line">    // 释放节点</span><br><span class="line">    zfree(node);</span><br><span class="line">    // 链表数减一</span><br><span class="line">    list-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个也没啥好看的，就是注意一下，当删除的节点是头尾节点时候的处理。</p>
<h1 id="链表的复制"><a href="#链表的复制" class="headerlink" title="链表的复制"></a>链表的复制</h1><p>这里面有个有意思实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listIter &#123;</span><br><span class="line"></span><br><span class="line">    // 当前迭代到的节点</span><br><span class="line">    listNode *next;</span><br><span class="line"></span><br><span class="line">    // 迭代的方向</span><br><span class="line">    int direction;</span><br><span class="line"></span><br><span class="line">&#125; listIter;</span><br><span class="line">\\遍历链表，返回当前节点</span><br><span class="line">listNode *listNext(listIter *iter)</span><br><span class="line">&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    if (current != NULL) &#123;</span><br><span class="line">        // 根据方向选择下一个节点</span><br><span class="line">        if (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            // 保存下一个节点，防止当前节点被删除而造成指针丢失</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        else</span><br><span class="line">            // 保存下一个节点，防止当前节点被删除而造成指针丢失</span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以实际使用时，可以采取这样的方式遍历链表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while((node = listNext(iter)) != NULL) </span><br><span class="line">&#123;</span><br><span class="line"> ....</span><br><span class="line"> fun(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>链表的复制，如果传入了复制函数，则调用传入的复制函数，否则只是指针还是指向value对应的地址。<br>详细实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">list *listDup(list *orig)</span><br><span class="line">&#123;</span><br><span class="line">    list *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line">    // 创建新链表</span><br><span class="line">    if ((copy = listCreate()) == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    // 设置节点值处理函数</span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;free = orig-&gt;free;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    // 迭代整个输入链表</span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    while((node = listNext(iter)) != NULL) &#123;</span><br><span class="line">        void *value;</span><br><span class="line">        // 复制节点值到新节点</span><br><span class="line">        if (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            if (value == NULL) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else</span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        // 将节点添加到链表</span><br><span class="line">        if (listAddNodeTail(copy, value) == NULL) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放迭代器</span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    // 返回副本</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>综上，这里面除了Iter和list结构体的设计有亮点以外，其他链表中各种操作的实现还是挺经典的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/01/redis源码阅读-简单动态字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chamlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chamlion'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/redis源码阅读-简单动态字符串/" itemprop="url">以redis源码阅读--简单动态字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-01T00:14:19+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计时考虑的点"><a href="#设计时考虑的点" class="headerlink" title="设计时考虑的点"></a>设计时考虑的点</h1><p>1、常数时间内获取到字符串长度<br>2、杜绝缓冲区溢出<br>3、减少修改字符串带来的内存重分配次数<br>4、二进制安全<br>是指无论字符串中包含何种字符，都不会对它的操作造成任何正确性的影响。<br>比如包含空字符(\0)的时候，应该能正常返回到字符串结尾的长度，而不是到空格的长度。而strlen()对字符串求长度时会有这个问题。<br>5、兼容部分c字符串函数</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先看结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    // buf 中已占用空间的长度</span><br><span class="line">    int len;</span><br><span class="line">    // buf 中剩余可用空间的长度</span><br><span class="line">    int free;</span><br><span class="line">    // 数据空间</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里面buff不用 char<em> buff的原因是 char buf[]不占空间，char</em> buff占用一个指针空间。<br>在获取字符串长度时，用到了这一特性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline size_t sdslen(const sds s) &#123;</span><br><span class="line">    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));</span><br><span class="line">    return sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传入的参数其实是buff地址。所以在结构体指针映射的时候，需要在buff的基础上，向左移动两位。<br>在获取可用空间长度时也是同样的道理。</p>
<h1 id="接下来看，如何创建字符串"><a href="#接下来看，如何创建字符串" class="headerlink" title="接下来看，如何创建字符串"></a>接下来看，如何创建字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sds sdsnewlen(const void *init, size_t initlen) &#123;</span><br><span class="line"></span><br><span class="line">    struct sdshdr *sh;</span><br><span class="line"></span><br><span class="line">    // 根据是否有初始化内容，选择适当的内存分配方式</span><br><span class="line">    // T = O(N)</span><br><span class="line">    if (init) &#123;</span><br><span class="line">        // zmalloc 不初始化所分配的内存</span><br><span class="line">        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // zcalloc 将分配的内存全部初始化为 0</span><br><span class="line">        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内存分配失败，返回</span><br><span class="line">    if (sh == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    // 设置初始化长度</span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    // 新 sds 不预留任何空间</span><br><span class="line">    sh-&gt;free = 0;</span><br><span class="line">    // 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span><br><span class="line">    // T = O(N)</span><br><span class="line">    if (initlen &amp;&amp; init)</span><br><span class="line">        memcpy(sh-&gt;buf, init, initlen);</span><br><span class="line">    // 以 \0 结尾</span><br><span class="line">    sh-&gt;buf[initlen] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">    // 返回 buf 部分，而不是整个 sdshdr</span><br><span class="line">    return (char*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，指定字符串长度后，实际申请的空间为sdshdr结构体大小+要申请字符串大小+1<br>其中+1是用来存储’\0’终止符，使其符合c字符串规范。<br>且申请的是连续内存。且创建完成后返回的是字符串地址。</p>
<h1 id="字符串扩容缩容操作"><a href="#字符串扩容缩容操作" class="headerlink" title="字符串扩容缩容操作"></a>字符串扩容缩容操作</h1><p>采取空间预分配进行优化，典型的空间换时间策略，具体扩容算法是<br>如果需要空间小于1MB直接，直接分配两倍的空间，如果大于1MB，在原来基础上多分配1M。<br>代码见<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line"> *返回值</span><br><span class="line"> *  sds ：扩展成功返回扩展后的 sds</span><br><span class="line"> *        扩展失败返回 NULL</span><br><span class="line"> *</span><br><span class="line"> * 复杂度</span><br><span class="line"> *  T = O(N)</span><br><span class="line"> */</span><br><span class="line">sds sdsMakeRoomFor(sds s, size_t addlen) &#123;</span><br><span class="line"></span><br><span class="line">    struct sdshdr *sh, *newsh;</span><br><span class="line"></span><br><span class="line">    // 获取 s 目前的空余空间长度</span><br><span class="line">    size_t free = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    size_t len, newlen;</span><br><span class="line"></span><br><span class="line">    // s 目前的空余空间已经足够，无须再进行扩展，直接返回</span><br><span class="line">    if (free &gt;= addlen) return s;</span><br><span class="line"></span><br><span class="line">    // 获取 s 目前已占用空间的长度</span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (void*) (s-(sizeof(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    // s 最少需要的长度</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line"></span><br><span class="line">    // 根据新长度，为 s 分配新空间所需的大小</span><br><span class="line">    if (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        // 如果新长度小于 SDS_MAX_PREALLOC </span><br><span class="line">        // 那么为它分配两倍于所需长度的空间</span><br><span class="line">        newlen *= 2;</span><br><span class="line">    else</span><br><span class="line">        // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    // T = O(N)</span><br><span class="line">    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);</span><br><span class="line"></span><br><span class="line">    // 内存不足，分配失败，返回</span><br><span class="line">    if (newsh == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    // 更新 sds 的空余长度</span><br><span class="line">    newsh-&gt;free = newlen - len;</span><br><span class="line"></span><br><span class="line">    // 返回 sds</span><br><span class="line">    return newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而对于字符串的缩短操作，比如trim操作，采取惰性空间释放，就是不释放。<br>最后提到的兼容部分C字符串函数，因为返回的就是字符串，所以不存在兼容性问题。</p>
<p>至此redis的动态字符串模块分析结束。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/28/以前笔记整理——C-小技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chamlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chamlion'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/28/以前笔记整理——C-小技巧/" itemprop="url">以前笔记整理——C++小技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-28T00:21:33+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、new操作符的重载"><a href="#1、new操作符的重载" class="headerlink" title="1、new操作符的重载"></a>1、new操作符的重载</h1><p> new的过程分成两部分，第一部分分配内存，第二部分调用构造函数。<br>重载new并不会影响调用构造函数，new的重载只是重载了分配内存那部分操作</p>
<h1 id="2、为什么free操作不需要指定大小"><a href="#2、为什么free操作不需要指定大小" class="headerlink" title="2、为什么free操作不需要指定大小"></a>2、为什么free操作不需要指定大小</h1><p> 因为在用malloc申请内存的时候，实际申请的是两个不同性质的空间，一块内存存储地址和实际申请内存大小的映射关系。一块空间为申请的内存。<br>Free操作，会先查找要free的地址与他申请内存大小的映射关系表，然后释放对应地址对应大小内存。<br>所以如下代码是一定有问题的<br>Char <em>b =(char </em>) malloc(100)<br>Free(b-10)</p>
<h1 id="3、-pragma-pack-1-的使用场景"><a href="#3、-pragma-pack-1-的使用场景" class="headerlink" title="3、#pragma pack(1)的使用场景"></a>3、#pragma pack(1)的使用场景</h1><p>  就是设置字节对齐策略，为了让类中成员所占内存大小，不受系统默认的对齐字节数影响。</p>
<h1 id="4、关于notifyone和notifyall的区别和使用场景"><a href="#4、关于notifyone和notifyall的区别和使用场景" class="headerlink" title="4、关于notifyone和notifyall的区别和使用场景"></a>4、关于notifyone和notifyall的区别和使用场景</h1><p> notifyone是对notifyall的一种优化，两个在实际使用中应该能相互替换<br>notifyone随机唤醒一个线程，notifyall唤醒所有线程去争用锁。<br>如果线程中存在优先级之分，应该用notifyall，否则用notifyone</p>
<h1 id="5、Ace栅栏的作用"><a href="#5、Ace栅栏的作用" class="headerlink" title="5、Ace栅栏的作用"></a>5、Ace栅栏的作用</h1><p>   用来实现一组线程进行共同的相互同步。<br>功能要求：一旦线程执行到栅栏点，线程阻塞，然后直到所有线程达到栅栏点以后，再一起继续执行。<br>Barrier实现：计数，未达到计数之前全部等待，达到计数之后，notifyall</p>
<h1 id="6、设置线程优先级"><a href="#6、设置线程优先级" class="headerlink" title="6、设置线程优先级"></a>6、设置线程优先级</h1><p>  Pthread_attr_t 可以通过这个设置线程的一些属性，比如设置线程为进程内竞争，还可以设置线程的调度策略，分为三种，分时调度策略，实时先到先服务策略，实时时间片轮转策略</p>
<h1 id="7、如何让线程按照顺序启动"><a href="#7、如何让线程按照顺序启动" class="headerlink" title="7、如何让线程按照顺序启动"></a>7、如何让线程按照顺序启动</h1><p>可以通过信号量控制<br>每启动一个函数，sem_wait等待一下。线程函数里面某个位置，调用sem_post<br>这样的话，可以继续创建线程</p>
<h1 id="8、如何减少锁争用"><a href="#8、如何减少锁争用" class="headerlink" title="8、如何减少锁争用"></a>8、如何减少锁争用</h1><p>一个思路，比如链表遍历。如果是单线程的，那么链表遍历就不需要考虑线程安全性。<br>那么当大量数据过来的时候，可以一个线程对应一个链表，先通过Hash算法将数据分散到每个线程的链表结构里面。<br>或者将处理时间比较长的函数调用之前做hash，despatch数据，然后处理完以后，统一交给一个处理池进行下一步处理。</p>
<h1 id="9、左值、右值"><a href="#9、左值、右值" class="headerlink" title="9、左值、右值"></a>9、左值、右值</h1><p>左值是指变量，可以放在等号左边<br>右值等号右边的值<br>左值引用 基本语法 type &amp; 引用名=左值表达式<br>右值引用 基本语法 type &amp;&amp;引用名 = 右值表达式</p>
<h1 id="10、结构体定义小技巧"><a href="#10、结构体定义小技巧" class="headerlink" title="10、结构体定义小技巧"></a>10、结构体定义小技巧</h1><pre><code>uint8_t Version:4,
         IHL:4
</code></pre><p>表示申请一个8bit的空间，其中4bit为version，4bit为IHL<br>还可以通过与运算取指定位数<br>比如8位的a，取其后四位 a&amp;00001111</p>
<h1 id="11、关于继承与多态"><a href="#11、关于继承与多态" class="headerlink" title="11、关于继承与多态"></a>11、关于继承与多态</h1><p> 继承的使用场景，当我们设计类中，确实需要用到多态这一特性的时候，考虑使用继承，否则使用组合。继承是is a的关系，组合是has a的关系</p>
<h1 id="12、多态的实现原理"><a href="#12、多态的实现原理" class="headerlink" title="12、多态的实现原理"></a>12、多态的实现原理</h1><p>一个类如果包含虚函数，那么会有一个虚函数表。虚函数指针指向这张虚函数表，如果声明一个子类对象时，虚函数表里面对应的是子类的虚函数。调用父类指针指向子类对象时，然后执行的是子类虚函数表中的函数，从而实现多态。多继承就是多个虚函数指针，指向多个虚函数表。<br>存在的问题，私有虚函数，可以通过指针调用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/26/2018-6-26-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chamlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chamlion'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/26/2018-6-26-1/" itemprop="url">2018-6-26</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-26T00:49:34+08:00">
                2018-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="chamlion" />
            
              <p class="site-author-name" itemprop="name">chamlion</p>
              <p class="site-description motion-element" itemprop="description">The world is so beautiful, it is worth people to strive for it</p>
          </div>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=28815383&auto=1&height=66"></iframe>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chamlion</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
